# -*- coding: utf-8 -*-
"""genetic painting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10b4kNpZ9eixgAJRZjDTHJ7QO3GK9hFpe

# Circle
"""

import random

class Circle:
    def __init__(self, canvas_width, canvas_height, radius, step_size):
        test_x_range = (int(canvas_width*0.3), int(canvas_width*0.7))
        test_y_range = (int(canvas_height*0.4),int(canvas_height*0.9))
        self.x, self.y = random.uniform (*test_x_range), random.uniform (*test_y_range)
        self.radius = radius
        self.step_size = step_size

    def mutate(self, mutation_rate):
        x_shift = int(random.randint (-self.step_size, self.step_size) * mutation_rate)
        y_shift = int(random.randint (-self.step_size, self.step_size) * mutation_rate)
        new_x = self.x + x_shift
        new_y = self.y + y_shift
        if new_x < self.radius:
            new_x = self.radius
        elif new_x > canvas_width - self.radius:
            new_x = int(canvas_width - self.radius)
        if new_y < self.radius:
            new_y = self.radius
        elif new_y > canvas_height - self.radius:
            new_y = int(canvas_height - self.radius)
        self.x = new_x
        self.y = new_y
  
    def get_points(self):
        return (self.x, self.y)

    def set_points(self,new_xypoints):
        newx_y = new_xypoints
        self.x = newx_y[0]
        self.y = newx_y[1]

# TEST CASE : CIRCLE OBJECT 
canvas_width = 800
canvas_height = 600
radius = 30
step_size = 10

circle = Circle(canvas_width, canvas_height, radius, step_size)
print(circle.x,circle.y)
circle.mutate(0.5)
print(circle.x,circle.y)

"""# Fitness"""

import numpy as np
from PIL import Image

def mse(target, generated): # find mse given target and generated image 
    target = target.convert('L')   # Convert images to grayscale
    generated = generated.convert('L')

    target = np.array(target)    # Convert images to numpy arrays
    generated = np.array(generated)
  
    diff_matrix = target - generated    # Calculate the element-wise difference between the two arrays
    squared_diff = np.square(diff_matrix)     # square both 
    MSE = np.mean(squared_diff) #  average difference among all the pixel value
    scaled_MSE = (255 * MSE) / (255**2) # assure spits between 0 and 1 

    return scaled_MSE

# # test case 
# target = Image.open('target.jpg') # leg of tower 
# target = target.convert('L')

# generated = Image.open('Inkedmydraw.jpg') # Load my hand written drawing
# generated = generated.convert('L')

# generated2 = Image.open('target.jpg') # compare target to target
# generated2 = generated2.convert('L')

# generated = generated.resize(target.size) # reset size of generate to target size
# print(mse(target, generated)) # error ratio : 0 (less error) is similar to target, 1 is different
# mse(target, generated2) # should be 0

"""# Paint"""

import numpy as np
from PIL import Image, ImageDraw

class Paint:
    def __init__(self, canvas_size, num_circles, target_image, radius, step_size, background_color, circle_color,mutateRate,proportionCircle):
        self.canvas_size = canvas_size
        self.num_circles = num_circles
        self.target_image = target_image
        self.radius = radius
        self.step_size = step_size
        self.background_color = background_color
        self.circle_color = circle_color
        self.draw = None

        self.fitnessScore = None # current fitness score
        self.circles = None # list of circles on this paint
        self.canvas = None  # current art paint
 
        self.mutationRate = mutateRate
        self.proportionCircle = proportionCircle # get mutation rate, and number on proportion of circle to mutate  
        self.paint_circles() # after an instance created, generate a paint
        
    def generate_circles(self): # generate a list of circles and store into paint instance 
      circles = []
      for i in range(self.num_circles):
          circle_x = np.random.randint(self.radius, self.canvas_size[0]-self.radius)
          circle_y = np.random.randint(self.radius, self.canvas_size[1]-self.radius)
          circle = Circle(circle_x, circle_y, self.radius, self.step_size)
          circles.append(circle)
      self.circles = circles

    def draw_single_circle(self, circleObject): # draw single circle onto canvas
        circle_x,circle_y  =  circleObject.get_points()[0],circleObject.get_points()[1]
        radius = self.radius
        rgb_list =  self.circle_color
        self.draw.ellipse((circle_x - radius, circle_y - radius, circle_x + radius, circle_y + radius), fill=rgb_list)

    def paint_circles(self): # paint all list of circles on canvas
        if self.canvas is None: # if canvas not created before, then we create
          self.canvas = Image.new('RGB', self.canvas_size, self.background_color)
          self.draw = ImageDraw.Draw(self.canvas) 
          self.generate_circles() # generate a list of circles 
          for i in range(len(self.circles)): # draw each circles on canvas
            self.draw_single_circle(self.circles[i])

        else: # if canvas exist, then create a new sheet of canvas. paint using existing list of circles 
          self.draw.rectangle([(0, 0), self.canvas_size], fill=self.background_color) # if circles existed, repaints canvas with white (to reflect update on mutation)
          for i in range(len(self.circles)): # draw each circles on canvas
            self.draw_single_circle(self.circles[i])

        self.set_fitScore() # once new paint is created or updated, we update fitness value

    def mutateCircles(self):
        num_mutations = int(self.proportionCircle * len(self.circles))            # choose a number circles to mutate based on set proportion 
        indices_to_mutate = random.sample(range(len(self.circles)), num_mutations)   # sample the circles for size of "num_mutations", and get their indice

        # print(self.get_points())
        for i in range(num_mutations): # iterate the circles that needs mutation 
          self.circles[indices_to_mutate[i]].mutate(self.mutationRate)
        # print(self.get_points())

        self.paint_circles() # once its mutated, re paint the canvas with new circles 

    def set_circles(self,new_crossover_circles): 
        list_circle_points = new_crossover_circles # update new circles 
        for i in range(len(self.circles)): # update to circle objecct
          self.circles[i].set_points(list_circle_points[i]) # send in new circles to each circles
       # self.paint_circles() # once its crossover, re paint the canvas with new circles 
        
    def set_fitScore(self): # update fitness score of the paint 
       self.fitnessScore = mse(self.target_image,self.canvas)
    

    def get_points(self): # get all points of each circles. 
      listPoints = []
      for i in range(len(self.circles)): # for each circles, get their x-y coordinates
        listPoints.append(self.circles[i].get_points())
      return listPoints

    def get_canvas(self): # return canvas 
      return self.canvas

    def get_fitScore(self): 
      return self.fitnessScore
    
# test case paint 

canvas_size = (180,279) # set params need for paint instance
num_circles = 6
radius = 10
step_size = 20
background_color = (255, 255, 255)
circle_color = (0, 0, 0)
target =   Image.open('images.png') # a subset of tower image 

mutateRate = 1.0
proportionCircle = 0.5
 
new_points = [(40.385391151331405, 118.31864832099427), (18.853581978117994, 166.1181620957844), (31.3601591318958, 99.28210423471648), (62.58576085929664, 86.63587870342816), (43.34063444570051, 82.20567525873159), (45.076942086476684, 74.55625927607504)]
 
# test : check mutate params is reflects
paint  = Paint(canvas_size,num_circles,target,radius, step_size, background_color, circle_color,mutateRate,proportionCircle) # create single paint instance 
print(paint.get_points())
paint.set_circles(new_points)
print(paint.get_points())

# paint.mutateCircles()
# print(paint.get_points())
# paint.get_canvas()

"""# Generate population"""

# generate population

def generate_population(population_size,paint_params,previous_population,mutateRate,proportionCircle):
  population = []
  # print(mutateRate,proportionCircle)
    # def __init__(self, canvas_size, num_circles, target_image, radius, step_size, background_color, circle_color,mutateRate,proportionCircle):

  if previous_population is not None:             # if previous population exist, we populate them into new initialized population
      for j in range(len(previous_population)):
        population.append(previous_population[j]) # adding the old population 
      print(population)
      for i in range(population_size- len(previous_population)):  # adding the new population. Note, we only populate the remaninng slot after old is added 
        paint_object = Paint(paint_params['canvas_size'], paint_params['num_circles'], paint_params['target'], paint_params['radius'], paint_params['step_size'], paint_params['background_color'], paint_params['circle_color'],mutateRate,proportionCircle)
        population.append(paint_object)
     #  print(population)
  else:                               #  if no previous population exist, we generate new population
      for i in range(population_size):
        paint_object = Paint(paint_params['canvas_size'], paint_params['num_circles'], paint_params['target'], paint_params['radius'], paint_params['step_size'], paint_params['background_color'], paint_params['circle_color'],mutateRate,proportionCircle)
        population.append(paint_object)
  return population
  
# test case 
# target = Image.open('target.jpg') # load target image. leg of tower 
# target = target.convert('L')

# population_size = 3

# paint_params  = {
#     'canvas_size': (194,214),
#     'num_circles': 4,
#     'target' : target,
#     'radius': 5,
#     'step_size': 20,
#     'background_color': (255, 255, 255),
#     'circle_color': (0, 0, 0)
# }

 
# mutateRate = 1.0 
# proportionCircle =  1.0

# previous_population = [paint]  # test case 1: existing population 
# pop = generate_population(population_size,paint_params,previous_population,mutateRate,proportionCircle) # t1 - initial 

# for i in range(len(pop)): # test : check mutation is working 
#   print(pop[i].get_points())
#   pop[i].mutateCircles()
#   print(pop[i].get_points())
#   print()

# pop[0].get_canvas()

# pop[0].mutateCircles()
# pop[0].get_canvas()

"""# Show population
 
"""

import numpy as np
from PIL import Image
def display_population(population):  # show each population in image, with fit score 
    fit_score = [score.get_fitScore() for score in population]
    images = [paint.get_canvas() for paint in population]
    images_np = [np.array(image.convert('RGB')) for image in images]
    combined_image = np.concatenate(images_np, axis=1)
    combined_image = Image.fromarray(combined_image)
    print(fit_score)
    combined_image.show()
# display_population(pop) # previously defined

# previous_population2 =  [paintObj1] # 
# pop2 = generate_population(population_size,paint_params,previous_population2,mutateRate,proportionCircle) # test function 
# display_population(pop2) # check whether each the previous population is added

"""# Tournament"""

def tournament_selection(population, tournament_params): 

    tournament_size , NumWinner = tournament_params['tournament_size'],tournament_params['NumWinner'] # store the parameter
    winner_list = [] # store winner paint that won at each tounament round

    # display_population(population) # for test 
    
    for j in range(NumWinner): # iterate "NumWinners" times of tournament
      competitors = random.sample(population,tournament_size)  # store the selected subset of paints
      fit_list = [] # store fitness score of the subset paints 

      # display_population(competitors) # for test 

      for i in range(tournament_size): # iterate over each subset paints 
        fit_list.append(competitors[i].get_fitScore())  # get fitness for each paint 
      
      MaxFit_index = fit_list.index(min(fit_list)) # get index that has lowest error ( paint closer to target)
      

      winner_list.append(competitors[MaxFit_index]) # add winner to the list as return paints
    
    # display_population(winner_list) # for test 
    return winner_list
    
# previous_population = None
# population = generate_population(population_size,paint_params,previous_population,mutateRate,proportionCircle) # previosly defined Generate sec

# tournament_params = {
#     'tournament_size': 2, # number of subset paint to pick
#     'NumWinner': 3        # number of tournament rounds to do
# }

# # winner_list = tournament_selection(pop2, tournament_params)  # pop2 : from show population test case 2
# # display_population(winner_list)

"""# Crossover"""

from random import shuffle

def crossover(population,subset_size,num_offspring):
    subset = random.sample(population,subset_size)  
    num_circle = subset[0].num_circles
    indexes_subset = list(range(len(subset))) 
    shuffle(indexes_subset)
    
    all_offspring = [] 
    for i in range(num_offspring):
      new_circles = [] 
      for c in range(num_circle):
        selected_parent_index  = random.choice(indexes_subset)
    
        selected_parent = subset[selected_parent_index]  # get the parents
        selected_point = selected_parent.get_points()[c]
        new_circles.append(selected_point)

      # take 1 parents from subset paint object and update its new crossed circles. then represent as a offspring
      offspring = subset[random.randint(0,len(subset)-1)]
      offspring.set_circles(new_circles)
      all_offspring.append(offspring)

    return all_offspring

# test case 
target = Image.open('images.png') # load target image. leg of tower 
target = target.convert('L')

population_size = 3

paint_params  = {
    'canvas_size': (180,279),
    'num_circles': 6,
    'target' : target,
    'radius': 5,
    'step_size': 20,
    'background_color': (255, 255, 255),
    'circle_color': (0, 0, 0)
}

 
mutateRate = 1.0 
proportionCircle =  1.0

previous_population = None # test case 1: existing population 
population = generate_population(population_size,paint_params,previous_population,mutateRate,proportionCircle) # t1 - initial 
subset_size= 3 # this should match num offspring at tournament
number_offspring = 4  

offspring = crossover(population,subset_size,number_offspring)
offspring

"""# Generate art
 

"""

# mutate 
def generate_art(population_size,paint_params,mutateRate,proportionCircle,tournament_params,iteration,subset_size,num_offspring):
 
    previous_population = None 
    for i in range(iteration):
      print("\033[33miteration\033[0m", i)
    
      population = generate_population(population_size,paint_params,previous_population,mutateRate,proportionCircle) # generate population 
      random.shuffle(population)
      # display_population(population) # display fitscore and canvas

      competed  = tournament_selection(population, tournament_params)  # do tournament selection generated population 
      # display_population(competed) 

      for j in range(len(competed)): # mutate population ran through tournament selection 
        competed[j].mutateCircles()
       
      mutated = competed # store the mutated population 
      # display_population(mutated)
    
      offspring = crossover(mutated,subset_size,num_offspring) # crossover 
      # display_population(offspring)

      if i % 500 == 0:

        display_population(population)
        display_population(competed)
        display_population(mutated)
        display_population(offspring)

      previous_population = offspring

import pandas as pd
pd.options.display.max_rows = 9999
pd.options.display.max_columns = 9999
pd.options.display.max_colwidth = 9999

# Load the target image and convert it to grayscale
target = Image.open('images.png')
target = target.convert('L')

# Define the parameters for the generated paintings
canvas_size = (180, 279)
num_circles = 25
radius = 10
step_size = 7# Decrease the step size to increase resolution
background_color = (255, 255, 255)
circle_color = (0, 0, 0)

paint_params = {'canvas_size': canvas_size, 'num_circles': num_circles, 'target': target, 'radius': radius,
                'step_size': step_size, 'background_color': background_color, 'circle_color': circle_color}

# Set the population size to 50 to balance between speed and diversity
population_size = 50
mutateRate = 0.8  # Decrease the mutation rate to increase stability
proportionCircle = 0.6

tournament_params = {'tournament_size': 25, 'NumWinner': 20} # its a good value (increase diversity)

iteration = 100000

subset_size = 20
num_offspring = 10

# Generate the art using the defined parameters
generate_art(population_size, paint_params, mutateRate, proportionCircle, tournament_params, iteration, subset_size, num_offspring)

import matplotlib.pyplot as plt

scores = [3, 3, 2,1,1] # the scores given by the 5 people you surveyed

# Calculate the average score
average = sum(scores) / len(scores)

# Plot the scores as a bar graph
plt.bar(range(len(scores)), scores)

# Add a line to indicate the average score
plt.axhline(y=average, color='r', linestyle='--')

# Add labels and title to the graph
plt.xlabel('Participant')
plt.ylabel('Score')
plt.title('Subjective Evaluation of Generated Image: Q2')

# Show the graph
plt.show()